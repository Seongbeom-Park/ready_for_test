// [1-6] 생각의 흐름. 생각 완료한 뒤 코드를 작성함 
#include <stdio.h>
#include <stdlib.h>

#define MAX 1000
//int graph[MAX][MAX];
int memo[MAX][MAX];

int max(int a, int b) {
	if (a>b) return a;
	return b;
}

int main() {
	int n;
	scanf("%d", &n);
	
	int i;
	for (i=0; i<n; i++) {
		int j;
//		for (j=0; j<=i; j++) { // [1] 0일 때 1번 받아야 함 
		for (j=0; j<n-i; j++) { // [5] 0일 때 5번 입력 받아야 함. 4일 때 1번 입력 받아야 함 
			int cost;
			scanf("%d", &cost); // [1] 여기까지 작성하고 저장하고 실행해봄
			// [3] 첫 번째는 자기 값 입력
			if (i == 0) memo[i][j] = cost;
			// [3] 다음 부터는 위와 오른쪽 위 값 중 큰값과 cost 더하기. max 구현해야겠다. 
			else memo[i][j] = max(memo[i-1][j], memo[i-1][j+1]) + cost;  
		}
	}
	// [3] 계산이 완료되었으니 결과값을 출력하자
	printf("%d", memo[n-1][0]); 

	return 0;
}

/*
[2]

DFS? 방향성 있는 그래프로 연산해야 하네? 귀찮아. 다른 방법 없을까?
한 층 올라갈 때 이전 결과에 영향을 안미치네? DP로 풀어봐야겠다

5
4 5 2 6 5
2 7 4 4
8 1 0
3 8
7

입력이 이렇게 되니까. 처음에는 비용이 입력값과 동일하고
4 5 2 6 5

다음 줄은 바로 위와 오른쪽 위의 비용 중 큰 값에 현재 비용을 더하면 되겠네
max(4, 5)+2 max(5, 2)+7 max(2, 6)+4 max(6, 5)+4

i번째 줄의 j번째 비용은 다음과 같구나 
max(memo[i-1][j], memo[i-1][j+1]) + graph[i][j]

입력 받으면서 바로 처리해도 될 것 같아보여
오버플로우나 언더플로우가 발생하지 않을 것 같아 
첫 번째 줄은 자기 값을 입력하게 해야겠다 
입력 받자 마자 바로 처리할 것이니까 graph는 필요 없겠다
 
*/

/*
[4] 23이 출력되네 실제로 값을 대입해서 확인해봐야지
memo[0] 4 5 2 6 5 
5+2 5+7 6+4 6+4
memo[1] 7 12 10 10
12+8 12+1 10+0
memo[2] 20 13 10
20+3 13+8
memo[3] 23 21
23+7
memo[4] 30

마지막 값이 아니라 한 칸 위 값이 출력되네?
아 입력을 잘못 받고 있구나? 
 
*/

/*
[6]
2중 for문 반복 횟수 수정하니 잘 동작하네 
*/
